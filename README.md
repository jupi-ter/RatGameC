# RatEngine

A lightweight 2D game engine written in C using data-oriented design principles. Built for integration with the (Whisker)[https://github.com/jupi-ter/Whisker] scripting language transpiler.

## Overview

RatEngine is a minimal, performance-focused game engine using structure-of-arrays (SoA) architecture for efficient data access. The engine provides core systems for entity management, rendering, collision detection, and input handling, designed to work seamlessly with code generated by the Whisker transpiler.

## Features

- Entity-Component-System (ECS) architecture with data-oriented design
- Sprite rendering with animation support
- Rectangle and circle collision detection
- Keyboard input handling
- Pixel-perfect rendering with automatic scaling
- Tile grid system for level data
- Timer system for delayed callbacks
- Integration with raylib for graphics and windowing

## Prerequisites

- GCC or compatible C compiler
- Make
- raylib library

## Installation

### Install raylib

```bash
# Ubuntu/Debian
sudo apt install libraylib-dev

# Or build from source
git clone https://github.com/raysan5/raylib.git
cd raylib/src
make PLATFORM=DESKTOP
sudo make install
```

### Build RatEngine

```bash
git clone https://github.com/yourusername/RatGameC
cd RatGameC
make
```

This creates the `game` executable in the `build/` directory.

## Project Structure

```
RatGameC/
├── src/
│   ├── main.c              # Entry point
│   ├── entity.c/h          # Entity registry and lifecycle
│   ├── collision.c/h       # Collision detection and queries
│   ├── transform.c/h       # Position and scale components
│   ├── renderable.c/h      # Sprite rendering components
│   ├── input.c/h           # Keyboard input handling
│   ├── sprite.c/h          # Sprite loading and management
│   ├── renderer.c/h        # Render target and scaling
│   ├── timer.c/h           # Frame-based timers
│   ├── tile.c/h            # Tile grid and level loading
│   ├── vector2.c/h         # 2D vector math
│   ├── utils.h             # Utility macros
│   ├── forward.h           # Forward declarations
│   ├── game_generated.c/h  # Generated by Whisker transpiler
│   └── Makefile
└── assets/
    ├── sprites/            # PNG sprite files
    └── levels/             # Level data files (.rat)
```

## Architecture

### Entity System

Entities are managed through a swap-and-pop system for cache-friendly iteration:

- **EntityRegistry** - Tracks entity lifecycle and collision shapes
- **TransformArray** - Position, scale, and rotation data
- **RenderableArray** - Sprite and animation state
- **CircleArray** / **RectangleArray** - Collision shapes

All component arrays are indexed by entity ID for direct lookup.

### Component Arrays

The engine uses structure-of-arrays (SoA) design:

```c
// Instead of this (Array of Structures):
struct Entity {
    Transform transform;
    Renderable renderable;
    CollisionShape collision;
};

// We use this (Structure of Arrays):
TransformArray transforms;
RenderableArray renderables;
CollisionShape* collision_types;
```

This improves cache locality when iterating over components of the same type.

### Collision System

Two-phase collision detection:

1. **Broad phase** - Checks all entities with collision shapes
2. **Collision callbacks** - Dispatches to entity-specific handlers

Supports:
- Rectangle vs Rectangle
- Circle vs Circle  
- Circle vs Rectangle

The `sync_collisions_with_transforms()` function updates collision positions from transform data every frame.

### Rendering Pipeline

```
1. Game logic updates (game_update)
2. Sync collisions with transforms
3. Check collisions and fire callbacks
4. Update sprite animations
5. Render to internal buffer (128x128 by default)
6. Scale and display to window
```

The renderer uses a fixed internal resolution that scales to the window size while maintaining aspect ratio.

## Integration with Whisker

The engine is designed to work with code generated by the (Whisker transpiler)[https://github.com/jupi-ter/Whisker]:

1. Write game logic in Whisker (.wsk files)
2. Transpiler generates `game_generated.h` and `game_generated.c`
3. Engine compiles and links with generated code
4. Generated code implements:
   - Entity type definitions
   - Lifecycle functions (create/update/destroy/collision)
   - Game initialization and cleanup
   - Collision dispatching

### Generated Code Interface

Whisker generates these functions that the engine calls:

```c
void game_init(GameState* game);           // Initialize game state
void game_update(GameState* game);         // Update all entities
void game_cleanup(GameState* game);        // Cleanup on exit
void dispatch_collision(GameState* game,   // Handle collisions
                       uint32_t id1, 
                       uint32_t id2);
```

## Sprite System

Sprites are loaded on-demand and cached:

```c
typedef enum SpriteID {
    SPRITE_NONE,
    SPRITE_WALL,
    SPRITE_PLAYER,
    SPRITE_COUNT
} SpriteID;
```

To add new sprites:

1. Add PNG files to `assets/sprites/`
2. Add enum entry to `sprite.h`
3. Add sprite data to `SPRITE_DATA` array in `sprite.c`

Multi-frame sprites use the naming convention: `sprite_0.png`, `sprite_1.png`, etc.

## Input System

Keyboard input is exposed through simple check functions:

```c
int keyboard_check(int key);           // Is key currently held?
int keyboard_check_pressed(int key);   // Was key just pressed?
int keyboard_check_released(int key);  // Was key just released?
```

Key constants are defined in `input.h` (e.g., `KEY_RIGHT`, `KEY_SPACE`).

## Level System

Levels are loaded from `.rat` files with a simple text format:

```
# Comment
WIDTH 128 HEIGHT 128
wall 0 0
wall 1 0
player_position 8 8
```

The tile grid system handles collision detection against static level geometry.

## Building and Running

### Debug Build
```bash
make
./build/game
```

### Clean Build
```bash
make clean
make
```

### Development Workflow

1. Edit Whisker scripts
2. Run transpiler: `./whisker script.wsk`
3. Rebuild engine: `make`
4. Run game: `./build/game`

## Configuration

### Window Settings

Configured in `main.c`:

```c
int SCALE_FACTOR = 4;  // Window scale multiplier
int game_w = 128;      // Internal game width
int game_h = 128;      // Internal game height
```

### Performance Settings

```c
SetTargetFPS(60);      // Frame rate cap
```

## Memory Management

The engine uses dynamic arrays that grow as needed:

- Initial capacity: 16 entities
- Growth strategy: Double capacity when full
- Cleanup: All arrays freed in `game_cleanup()`

Entity destruction uses swap-and-pop to maintain dense arrays without fragmentation.

## Known Limitations

- No spatial partitioning (collision checks are O(n²))
- Maximum 128 entities by default
- Single-threaded execution
- No audio system
- No particle system
- Tile system not integrated with generated code

## Roadmap

### Planned Features
- Spatial hash grid for collision optimization
- Camera system
- Particle effects
- Sound management
- Hot reload support
- Gamepad input
- Networked multiplayer foundation

## Performance Characteristics

Designed for lightweight games targeting older hardware:

- Pixel art aesthetics
- Fixed timestep at 60 FPS
- Cache-friendly data layout
- Minimal allocations during gameplay

## Debugging

There's currently no debugging baked in.

## Contributing

This is a personal learning project. Issues and pull requests are welcome but may not be immediately addressed.

## License

MIT License - see LICENSE file for details
